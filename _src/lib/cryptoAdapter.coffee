# # CryptoAdapter

#
# ### Exports: *Instance*
#
# This is a adapter to centralize the usage of different crypto modules
# 

class CryptoAdapter
	
	###
	## setModule
	
	`CryptoAdapter.setModule( tmpl, data )`
	
	The the crypto module and set the method `hmacSha256`
	
	@param { String } [cryptoModule=`crypto`] The module name of the used crypto module. Possible modules are the node internal "crypto" or the browser compatible ["crypto"](https://www.npmjs.com/package/crypto-js) module

	@return { CryptoAdapter } A self reference
	
	@api private
	###
	setModule: ( cryptoModule = "crypto" )->
		@crypto = require( cryptoModule )
		switch cryptoModule
			when "crypto-js"
				@hmacSha256 = @_hmacSha256_CryptoJs
			else
				@hmacSha256 = @_hmacSha256_Crypto
		return @
	
	###
	## hmacSha256
	
	`CryptoAdapter.hmacSha256( secret, val[, secinp, out] )`
	
	calculate a hmac shah 256 hash
	
	@param { String } secret The secret to generate the hash
	@param { String } val The value to generate the hash of
	@param { String } [secinp="hex"] The input encoding of the secret. ( Enum: `hex`, `base64`, `utf8` )
	@param { String } [out="hex"] The output encoding of the generated hash. ( Enum: `hex`, `base64`, `utf8` )

	@return { String } The generated hash
	
	@api private
	###
	# This is a virtual method that is generated by `setModule` based on the defined crypto module
	
	###
	## _hmacSha256_Crypto
	
	`CryptoAdapter._hmacSha256_Crypto( secret, val[, secinp, out] )`
	
	The node internal version of `hmacSha256` using the `crypto` module
	
	@param { String } secret The secret to generate the hash
	@param { String } val The value to generate the hash of
	@param { String } [secinp="hex"] The input encoding of the secret. ( Enum: `hex`, `base64`, `utf8` )
	@param { String } [out="hex"] The output encoding of the generated hash. ( Enum: `hex`, `base64`, `utf8` )

	@return { String } The generated hash
	
	@api private
	###
	_hmacSha256_Crypto: ( secret, val, secinp="hex", out="hex" )=>
		_hash = @crypto.createHmac('SHA256', new Buffer( secret, secinp ) ).update( val )
		return _hash.digest( out )
	
	###
	## _hmacSha256_CryptoJs
	
	`CryptoAdapter._hmacSha256_CryptoJs( secret, val[, secinp, out] )`
	
	The browser version of `hmacSha256` using the `crypto-js` module
	
	@param { String } secret The secret to generate the hash
	@param { String } val The value to generate the hash of
	@param { String } [secinp="hex"] The input encoding of the secret. ( Enum: `hex`, `base64`, `utf8` )
	@param { String } [out="hex"] The output encoding of the generated hash. ( Enum: `hex`, `base64`, `utf8` )

	@return { String } The generated hash
	
	@api private
	###
	_hmacSha256_CryptoJs: ( secret, val, secinp="hex", out="hex" )=>
		_secinpEnc = @_cryptoJsEnc( secinp )
		_outEnc = @_cryptoJsEnc( out )
		_hash = @crypto.HmacSHA256( val, _secinpEnc.parse( secret ) )
		return _hash.toString(_outEnc )
	
	###
	## _cryptoJsEnc
	
	`CryptoAdapter._cryptoJsEnc( enc )`
	
	`crypto-js` helper to grab the right encoder

	@param { String } [enc="hex"] The encoding key. ( Enum: `hex`, `base64`, `utf8` )

	@return { CryptoJs.Enc } A crypto-js encoder
	
	@api private
	###
	_cryptoJsEnc: ( enc="hex" )=>
		return switch enc
			when "base64" then @crypto.enc.Base64
			when "hex" then @crypto.enc.Hex
			when "utf8" then @crypto.enc.Utf8

# export a instance
module.exports = new CryptoAdapter()
	
